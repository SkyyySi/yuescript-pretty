#!/usr/bin/env yue
--- SPDX-License-Identifier: 0BSD

from _G import type, error, assert, print, tostring, ipairs, io, os, debug, table, string, getmetatable, setmetatable

import "pretty.color"


export check_arguments = (func_name, arguments) ->
	for arg in *arguments
		const [index, name, expected_type, value] = arg

		const type_of_value = type(value)

		if type_of_value == expected_type
			continue

		error("Wrong type of argument #%d %q to function %q! (expected %s, got: %s)"::format(
			index,
			name,
			func_name,
			expected_type,
			type_of_value,
		))


export unpack = table.unpack ?? _G.unpack


export pack = (...) ->
	with { ... }
		.n = select("#", ...)


export split = (str, delimiter_pattern="%s+") ->
	check_arguments("pretty.util.split", [
		[1, "str",               "string", str],
		[2, "delimiter_pattern", "string", delimiter_pattern],
	])

	assert(
		delimiter_pattern != "",
		"The delimiter pattern must not be an empty string!",
	)

	const result = []

	local last_match_end = 0
	for match, i in str::gmatch("(.-)" .. delimiter_pattern .. "()")
		last_match_end = i
		result[] = match

	result[] = str::sub(last_match_end)

	result


-- https://en.wikipedia.org/wiki/Control_Pictures
const unicode_control_pictures = do
	const temp = string.char(226) .. string.char(144)
	{ string.char(i), temp .. string.char(i + 128) for i = 0, 31 }

const named_escapes = {
	"\\": "\\\\",
	"\a": "\\a",
	"\b": "\\b",
	"\027": "\\e",
	"\f": "\\f",
	"\n": "\\n",
	"\r": "\\r",
	"\t": "\\t",
	"\v": "\\v",
	"\"": "\\\"",
	"\'": "\\\'",
}

const decimal_escapes = { string.char(i), "\\%03d"::format(i) for i = 0, 255 }

const hexadecimal_escapes = { string.char(i), "\\x%02X"::format(i) for i = 0, 255 }

const unmapped_characters = do
	const temp = { string.char(i), string.char(i) for i = 32, 126 }
	temp["\\"] = "\\"
	temp["\027"] = "\027"
	temp

const quote_char_map = {
	--...decimal_escapes,
	...hexadecimal_escapes,
	...unicode_control_pictures,
	...unmapped_characters,
	...named_escapes,
}


export quote = (str, options={}) ->
	options.quote_char_map ??= quote_char_map
	options.quote_escape_highlighter ??= (escape) ->
		"\027[1;7m" .. escape .. "\027[22;27m"
	options.quote_string_base_color ??= options.string_base_color ?? { fg: "yellow" }

	check_arguments("pretty.util.quote", [
		[1, "str", "string", str],
	])

	const quote_char = if str::find('"') and not str::find("'")
		"'"
	else
		'"'

	local skip_until_pos = nil
	color.set(options.quote_string_base_color, options) ..
	quote_char ..
	str::gsub(
		"()([%z\001-\255])",
		(pos, char) ->
			const mapped_char = options.quote_char_map[char] ?? char

			return if skip_until_pos?
				if pos < skip_until_pos
					mapped_char
				else
					skip_until_pos = nil
					"\027[0m" .. mapped_char
			elseif ansi_color_escape := str::sub(pos)::match("^\027%[[0-9;]-m")
				skip_until_pos = pos + #ansi_color_escape
				"\027[0m#{ansi_color_escape}\\e"
			elseif mapped_char == char
				char
			else
				options.quote_escape_highlighter(mapped_char)
	) ..
	color.set(options.quote_string_base_color, options) ..
	quote_char


export main = (argv=arg) ->
	--const test_string_1 = "foo bar biz  baz"
	--for k, v in ipairs(split(test_string_1, " "))
	--	print(k, "%q"::format(v))

	const test_string_2 = table.concat([string.char(i) for i = 0, 255]) ..
		"\027[1;31;45mColor test\027[0m"
	print("\027[0m" .. quote(test_string_2) .. "\027[0m")


if select("#", ...) == 0
	os.exit(main())
