#!/usr/bin/env yue
--- SPDX-License-Identifier: 0BSD

from _G import type, error, assert, print, tostring, ipairs, io, os, debug, table, string, getmetatable, setmetatable


export check_arguments = (func_name, arguments) ->
	for arg in *arguments
		const [index, name, expected_type, value] = arg

		const type_of_value = type(value)

		if type_of_value == expected_type
			continue

		error("Wrong type of argument #%d %q to function %q! (expected %s, got: %s)"::format(
			index,
			name,
			func_name,
			expected_type,
			type_of_value,
		))


export unpack = table.unpack ?? _G.unpack


export pack = (...) ->
	with { ... }
		.n = select("#", ...)


export split = (str, delimiter_pattern="%s+") ->
	check_arguments("pretty.util.split", [
		[1, "str",               "string", str],
		[2, "delimiter_pattern", "string", delimiter_pattern],
	])

	assert(
		delimiter_pattern != "",
		"The delimiter pattern must not be an empty string!",
	)

	const result = []

	local last_match_end = 0
	for match, i in str::gmatch("(.-)" .. delimiter_pattern .. "()")
		last_match_end = i
		result[] = match

	result[] = str::sub(last_match_end)

	result


export quote = (str) ->
	check_arguments("pretty.util.quote", [
		[1, "str", "string", str],
	])

	const quote_char = if str::find('"') and not str::find("'")
		"'"
	else
		'"'

	quote_char .. str::gsub("[%z\001-\031\127-\255]", (char) ->
		if named_escape := ({
			"\a": "\\a",
			"\b": "\\b",
			"\f": "\\f",
			"\n": "\\n",
			"\r": "\\r",
			"\t": "\\t",
			"\v": "\\v",
		})[char]
			return named_escape

		"\\%03d"::format(char::byte())
	) .. quote_char


export main = (argv=arg) ->
	const test_string_1 = "foo bar biz  baz"
	for k, v in ipairs(split(test_string_1, " "))
		print(k, "%q"::format(v))

	const test_string_2 = table.concat([string.char(i) for i = 0, 255])
	print(quote(test_string_2))


if select("#", ...) == 0
	os.exit(main())
